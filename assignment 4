import unittest
import scipy.stats
import numpy as np
import matplotlib.pyplot as plt

class SignalDetection: 
    def __init__ (self, hits, misses, falseAlarms, correctRejections):
        self.hits = hits
        self.misses = misses 
        self.falseAlarms = falseAlarms
        self.correctRejections = correctRejections 

    def hitrate(self):
        return self.hits/(self.hits + self.misses)
    
    def farate(self):
        return self.falseAlarms/(self.falseAlarms+self.correctRejections)
    
    def d_prime(self):
        return scipy.stats.norm.ppf(self.hitrate()) - scipy.stats.norm.ppf(self.farate())
    
    def criterion(self):
        return  -0.5 * (scipy.stats.norm.ppf(self.hitrate())+ scipy.stats.norm.ppf(self.farate()))
    
    def __add__(self, other):
         hits = self.hits + other.hits
         misses = self.misses + other.misses 
         falseAlarms = self.falseAlarms + other.falseAlarms
         correctRejections = self.correctRejections + other.correctRejections
         return SignalDetection(hits, misses, falseAlarms, correctRejections) 
    
    def __mul__(self, scalar):
        hits = self.hits * scalar 
        misses = self.misses * scalar
        falseAlarms = self.falseAlarms * scalar
        correctRejections = self.correctRejections * scalar
        return SignalDetection(hits, misses, falseAlarms, correctRejections)
    
    def plot_roc(self):
        # Calculate the hit rate and false alarm rate for each object
        hitrate = self.hitrate()
        falsealarm = self.farate()
    
        #coordinates to make the line go from (0,0) - (falsealarm,hitrate) - (1,1)
        x_coords = [0.0, falsealarm, 1.0]
        y_coords = [0.0, hitrate, 1.0]

        #plotting and design
        plt.plot(x_coords, y_coords, 'bo-', label = 'ROC curve')
        plt.plot([0, 1], [0, 1], 'k-', label = 'reference line') # diagonal line for reference
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.0])
        plt.xlabel('False Alarm Rate')
        plt.ylabel('Hit Rate')
        plt.title('Receiver Operating Characteristic (ROC) Curve')
        plt.legend()
    
    def fit_roc():
        #this gives curve
        #this will be a harder one, using the optimization stuff 
        plt.show()
        pass
        #hint : write in a way that you dont have the plt.show yet

    def plot_sdt(self, d_prime):
        # Set up x values
        x = np.linspace(-4, 4, 1000)
    
        # Compute y values for noise and signal curves
        y_N = scipy.stats.norm.pdf(x, loc = 0, scale = 1) #norm dist with mean 0 and variance 1
        y_S = scipy.stats.norm.pdf(x, loc = d_prime, scale = 1) #norm dist with mean d' and varance 1
        c = d_prime/2 #optimal threshold

        #calculate tops of x and y
        Ntop_y = np.max(y_N)
        Nstop_x = x[np.argmax(y_N)]
        Stop_y = np.max(y_S)
        Stop_x = x[np.argmax(y_S)]
    

        # Plot curves and add annotations
        plt.plot(x, y_N, label="Noise") # plot N curve
        plt.plot(x, y_S, label="Signal") # plot S curve
        plt.axvline((d_prime/2)+ c,label = 'threshold', color='k', linestyle='--') # plot threshold line C
        plt.plot ([Nstop_x, Stop_x ],[ Ntop_y, Stop_y], label = "d'", linestyle = '-') #plot dprime line 
        plt.ylim(ymin=0)
        plt.xlabel('Decision Variable')
        plt.ylabel('Probability')
        plt.title('Signal detection theory')
        plt.legend()
        plt.show()

    @staticmethod
    def simulate(dprime, criteriaList, signalCount, noiseCount):
        sdtList = []
        for criterion in criteriaList:
            signal = np.random.normal(dprime, 1, signalCount)
            noise = np.random.normal(0, 1, noiseCount)

            hits = 0
            misses = 0 
            falseAlarms = 0
            correctRejections = 0

            for i in range(signalCount):
                if signal[i] > criterion:
                    hits += 1
                else:
                    misses += 1
            
            for i in range(noiseCount):
                if noise[i] > criterion:
                    falseAlarms += 1
                else:
                    correctRejections += 1
            sdt = SignalDetection(hits, misses, falseAlarms, correctRejections)
            sdtList.append(sdt)
        
        return sdtList

       
        #generate a static method, specifically static factory method
        #should take as input, a dprime, list of multiple criteria, a signal 
        #count and noise count, output array of signal detection objects each of
     

    def nLogLikelihood(self):
        # hitrate = 
        # falsealarm = 
        #either minimize loss function or maximize likeliehood function 
        #number of hits time the log of hit rate - all similar functions
        #takes as input, signal detection object, hypothetical hitrate and hypothetical farate - NOT THE SAME AS WAHT IS ALREADY IN THERE
        pass


    def rocLoss():
        pass
        


sd = SignalDetection(30,69,89,80)
sd.plot_roc()       
sd.plot_sdt(sd.d_prime())
#my_static_method = staticmethod(my_static_method)
        
class TestSignalDetection(unittest.TestCase):
    def test_d_prime_zero(self):
        sd   = SignalDetection(15, 5, 15, 5)
        expected = 0
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_d_prime_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        expected = -0.421142647060282
        obtained = sd.d_prime()
        # Compare calculated and expected d-prime
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_criterion_zero(self):
        sd   = SignalDetection(5, 5, 5, 5)
        # Calculate expected criterion
        expected = 0
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=10)

    def test_criterion_nonzero(self):
        sd   = SignalDetection(15, 10, 15, 5)
        # Calculate expected criterion
        expected = -0.463918426665941
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertAlmostEqual(obtained, expected, places=10)
    
    def test_for_corruption(self):
        sd = SignalDetection(15, 5, 15, 5)
        obtained1 = sd.d_prime()
        sd.hits = 9
        obtained2 = sd.d_prime()
        self.assertNotEqual(obtained1,obtained2)

    def test_addition(self):
        sd = SignalDetection(1, 1, 2, 1) + SignalDetection(2, 1, 1, 3)
        expected = SignalDetection(3, 2, 3, 4).criterion()
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertEqual(obtained, expected)

    def test_multiplication(self):
        sd = SignalDetection(1, 2, 3, 1) * 4
        expected = SignalDetection(4, 8, 12, 4).criterion()
        obtained = sd.criterion()
        # Compare calculated and expected criterion
        self.assertEqual(obtained, expected)

    def test_simulate_single_criterion(self):
        """
        Test SignalDetection.simulate method with a single criterion value.
        """
        dPrime       = 1.5
        criteriaList = [0]
        signalCount  = 1000
        noiseCount   = 1000
        
        sdtList      = SignalDetection.simulate(dPrime, criteriaList, signalCount, noiseCount)
        self.assertEqual(len(sdtList), 1)
        sdt = sdtList[0]
        
        self.assertEqual(sdt.hits             , sdtList[0].hits)
        self.assertEqual(sdt.misses           , sdtList[0].misses)
        self.assertEqual(sdt.falseAlarms      , sdtList[0].falseAlarms)
        self.assertEqual(sdt.correctRejections, sdtList[0].correctRejections)
    def test_simulate_multiple_criteria(self):
        """
        Test SignalDetection.simulate method with multiple criterion values.
        """
        dPrime       = 1.5
        criteriaList = [-0.5, 0, 0.5]
        signalCount  = 1000
        noiseCount   = 1000
        sdtList      = SignalDetection.simulate(dPrime, criteriaList, signalCount, noiseCount)
        self.assertEqual(len(sdtList), 3)
        for sdt in sdtList:
            self.assertLessEqual (sdt.hits              ,  signalCount)
            self.assertLessEqual (sdt.misses            ,  signalCount)
            self.assertLessEqual (sdt.falseAlarms       ,  noiseCount)
            self.assertLessEqual (sdt.correctRejections ,  noiseCount)

if __name__ == '__main__':
    unittest.main()